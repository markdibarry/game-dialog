// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using GameDialog.Runner;
using Godot;

namespace ExampleProject;

/// <summary>
/// An example RichTextLabel writer.
/// </summary>
[GlobalClass, Tool]
public partial class DialogTextLabel : RichTextLabel
{
    /// <summary>
    /// Creats a new DialogTextLabel instance.
    /// </summary>
    public DialogTextLabel()
    {
        VisibleCharactersBehavior = TextServer.VisibleCharactersBehavior.CharsAfterShaping;
        ClipContents = true;
        BbcodeEnabled = true;
        _scrollBar = GetVScrollBar();
        _scrollBar.AllowGreater = true;
        _scrollBar.Scale = Vector2.Zero;
        Reset();

        if (_theme == null)
        {
            _theme = new();
            _theme.SetStylebox("scroll", "VScrollBar", new StyleBoxEmpty());
        }

        Theme = _theme;
    }

    private static Theme _theme = default!;

    private const int DefaultCharsPerSecond = 30;
    private const int SpeedUpMultiplier = 3;
    private const float AutoTimeoutMultiplier = 0.05f;

    private bool _isWriting;
    private double _writeCounter;
    private Vector2I _targetWriteRange;
    private readonly VScrollBar _scrollBar;
    private bool _isScrolling;
    private double _targetScrollValue;
    // Although ScrollBar.Value is a double, it rounds on Set,
    // so an intermediate is necessary.
    private double _movingScrollValue;
    private readonly List<TextEvent> _textEvents = [];
    private int _textEventIndex;
    /// <summary>
    /// The speed, in characters per second, at which characters are written.
    /// </summary>
    [Export]
    public int CharsPerSecond { get; set; } = DefaultCharsPerSecond;

    /// <summary>
    /// The speed, in pixels per second, at which the text scrolls.
    /// </summary>
    [Export]
    public float ScrollSpeed
    {
        get;
        set => field = Math.Max(value, 0);
    }
    /// <summary>
    /// The interval, in pixes, at which the scroll visually updates.
    /// </summary>
    [Export]
    public float ScrollStep
    {
        get;
        set => field = Math.Max(value, 0);
    }
    /// <summary>
    /// A helper export button to write the next dialog line.
    /// </summary>
    [ExportToolButton("Write Next Line")]
    public Callable WriteNextLineButton => Callable.From(WriteNextLine);
    /// <summary>
    /// A helper export button to write the next dialog page.
    /// </summary>
    [ExportToolButton("Write Next Page")]
    public Callable WriteNextPageButton => Callable.From(WriteNextPage);
    /// <summary>
    /// A helper export button to reset the DialogTextLabel.
    /// </summary>
    [ExportToolButton("Reset")]
    public Callable ResetButton => Callable.From(Reset);
    /// <summary>
    /// Gets a cached RichTextLabel.Text.
    /// </summary>
    public string CachedText { get; private set; } = string.Empty;
    /// <summary>
    /// If true, the DialogTextLabel is currently writing text.
    /// </summary>
    public bool Writing => _isWriting;
    /// <summary>
    /// The total characters in the text.
    /// </summary>
    public int TotalChars { get; private set; }
    /// <summary>
    /// The base writing speed is determined by <c>CharsPerSecond</c> multiplied by this value.
    /// </summary>
    public double SpeedMultiplier { get; set; }
    /// <summary>
    /// If true, the base writing speed is multiplied by this value.
    /// </summary>
    public bool IsSpeedUpEnabled { get; set; }
    /// <summary>
    /// If true, the text will automatically proceed when it reaches the end of the line/page.
    /// </summary>
    public bool AutoProceedEnabled { get; set; }
    /// <summary>
    /// If true, the writing is temporarily suspended.
    /// </summary>
    public bool Suspended { get; private set; }
    /// <summary>
    /// The Dialog object. For parsing and handling text events.
    /// </summary>
    public Dialog? Dialog { get; set; }
    /// <summary>
    /// If <c>AutoProceedEnabled</c> is true, determines the amount of time after reaching the end 
    /// of the line/page before automatically proceeding.
    /// </summary>
    public float AutoProceedTimeout
    {
        get
        {
            double time = field;

            if (time == -1)
                time = (_targetWriteRange.Y - _targetWriteRange.X) * AutoTimeoutMultiplier;

            return (float)Math.Max(0, time);
        }
        set;
    }
    /// <summary>
    /// The amount of time left, in seconds, before the next char is written.
    /// </summary>
    public double PauseTimer
    {
        get;
        set => field = value >= 0 ? value : field;
    }

    /// <summary>
    /// Occurs when a character is written.
    /// </summary>
    public event CharacterWrittenHandler? CharWritten;
    /// <summary>
    /// Occurs when a TextEvent is triggered.
    /// </summary>
    public event TextEventTriggeredHandler? TextEventTriggered;
    /// <summary>
    /// Occurs when the DialogTextLabel finishes writing all available text.
    /// </summary>
    public event Action? FinishedWriting;

    /// <summary>
    /// Represents the method that will handle the CharWritten event.
    /// </summary>
    /// <param name="charIndex">The index of the char written.</param>
    /// <param name="charWritten">The char that was written.</param>
    public delegate void CharacterWrittenHandler(int charIndex, char charWritten);
    /// <summary>
    /// Represents the method that will handle the TextEventTriggered event.
    /// </summary>
    /// <param name="textEvent">The triggered TextEvent.</param>
    public delegate void TextEventTriggeredHandler(TextEvent textEvent);

    /// <inheritdoc/>
    public override void _Ready()
    {
        TextEventTriggered += OnTextEventTriggered;
    }

    /// <inheritdoc/>
    public override void _PhysicsProcess(double delta)
    {
        if (Suspended)
            return;

        if (PauseTimer > 0)
            PauseTimer = Math.Max(0, PauseTimer - delta);
        else if (_isScrolling)
            ScrollProcess(delta);
        else if (Writing)
            Write(delta);
    }

    /// <summary>
    /// Writes the next available text that can fit within the bounds of the RichTextLabel.
    /// </summary>
    public void WriteNextPage() => WriteNext(false);

    /// <summary>
    /// Writes the next available line of text.
    /// </summary>
    public void WriteNextLine() => WriteNext(true);

    /// <summary>
    /// Resumes writing the text.
    /// </summary>
    public void Resume() => Suspended = false;

    /// <summary>
    /// Parses text for TextEvents and sets the parsed text to <c>RichTextLabel.Text</c>.
    /// </summary>
    /// <param name="text">The unparsed text.</param>
    public void SetDialogText(string text) => ResetAndSetText(text);

    /// <summary>
    /// Resets the DialogTextLabel.
    /// </summary>
    public void Reset() => ResetAndSetText();

    /// <summary>
    /// Handles the TextEventTriggered event.
    /// </summary>
    /// <param name="textEvent">The triggered TextEvent.</param>
    public void OnTextEventTriggered(TextEvent textEvent)
    {
        if (Dialog == null)
            return;

        if (!Dialog.TryParseBuiltInEvent(textEvent, out EventType eventType, out float eventParam))
        {
            if (textEvent.Tag.Span.StartsWith("await "))
                Suspended = true;

            Dialog.TryEvaluateExpression(textEvent.Tag);
            return;
        }

        int currentChar = VisibleCharacters == -1 ? TotalChars : VisibleCharacters;

        switch (eventType)
        {
            case EventType.Pause:
                float timeValue = eventParam;
                PauseTimer += timeValue;
                break;
            case EventType.Speed:
                SpeedMultiplier = eventParam;
                break;
            case EventType.Auto:
                float autoValue = eventParam;
                AutoProceedEnabled = autoValue != -2;
                AutoProceedTimeout = autoValue;
                bool isComplete = currentChar == TotalChars;

                if (isComplete)
                    PauseTimer += AutoProceedTimeout;

                break;
            case EventType.Prompt:
                _targetWriteRange.Y = currentChar + 1;
                break;
            case EventType.Scroll:
                int currentLine = GetCharacterLine(currentChar);
                SetTargetScrollLine(currentLine);

                // Is this screen fully written?
                int lastFittingLine = GetLastFittingLine(_targetScrollValue);
                int lastFittingChar = GetLineRange(lastFittingLine).Y;

                if (currentChar != lastFittingChar)
                {
                    int firstFittingLine = GetFirstFittingLine(_targetScrollValue);
                    int firstChar = GetLineRange(firstFittingLine).X;
                    _targetWriteRange = new(firstChar, lastFittingChar);
                    _isWriting = true;
                }

                break;
        }
    }

    /// <summary>
    /// Determines if the DialogTextLabel has completed writing all available text.
    /// </summary>
    /// <returns>If true, the DialogTextLabel has completed writing all available text.</returns>
    public bool IsComplete() => VisibleCharacters == -1 || VisibleCharacters == TotalChars;

    /// <summary>
    /// Determines if the displayed text is the last available page.
    /// </summary>
    /// <returns>If true, the current page is the last available page.</returns>
    public bool IsOnLastPage() => _scrollBar.Value >= _scrollBar.MaxValue - Size.Y;

    /// <summary>
    /// Override of the _Set method to allow routing text to the <c>SetDialogText()</c> method in the editor.
    /// </summary>
    public override bool _Set(StringName property, Variant value)
    {
        if (property == RichTextLabel.PropertyName.Text)
        {
            if (value.Obj is string text)
                SetDialogText(text);

            return true;
        }

        return false;
    }

    /// <summary>
    /// Resets the DialogTextLabel and optionally sets new text.
    /// </summary>
    /// <param name="newText">The unparsed text to set.</param>
    private void ResetAndSetText(string? newText = null)
    {
        _textEvents.Clear();
        _textEventIndex = 0;
        VisibleCharacters = 0;

        if (newText != null && Dialog != null)
        {
            string eventParsedText = Dialog.ParseEventsFromText(newText, _textEvents);
            Text = eventParsedText;
            string displayedText = GetParsedText();
            CachedText = displayedText;
            Dialog.AdjustEventIndices(eventParsedText, displayedText, _textEvents);
        }

        TotalChars = GetTotalCharacterCount();
        _scrollBar.Value = 0;
        _targetScrollValue = 0;
        _movingScrollValue = 0;
        _targetWriteRange = new(0, GetLastFittingCharacter(0));

        PauseTimer = 0;
        AutoProceedEnabled = Dialog?.GlobalAutoProceedEnabled ?? false;
        AutoProceedTimeout = Dialog?.GlobalAutoProceedTimeout ?? 0;
        SpeedMultiplier = Dialog?.GlobalSpeedMultiplier ?? 0;
    }

    /// <summary>
    /// Sets up writing the next line or page.
    /// </summary>
    /// <param name="isLine">If false, writes a new page</param>
    private void WriteNext(bool isLine)
    {
        if (Writing || _isScrolling)
            return;

        int currentChar = VisibleCharacters == -1 ? TotalChars : VisibleCharacters;

        if (currentChar == TotalChars)
        {
            FinishedWriting?.Invoke();
            return;
        }

        _writeCounter = 1;
        // Is this screen fully written?
        int lastFittingLine = GetLastFittingLine(_targetScrollValue);
        int lastFittingChar = GetLineRange(lastFittingLine).Y;

        if (currentChar < lastFittingChar)
        {
            int firstFittingLine = GetFirstFittingLine(_targetScrollValue);
            int firstChar = GetLineRange(firstFittingLine).X;
            _targetWriteRange = new(firstChar, lastFittingChar);
            _isWriting = true;
            return;
        }

        int nextLine;

        if (isLine)
            nextLine = GetNextFittingLine(lastFittingLine);
        else
            nextLine = lastFittingLine + 1;

        SetTargetScrollLine(nextLine);
        int charStart = GetLineRange(nextLine).X;
        int charEnd = GetLastFittingCharacter(_targetScrollValue);
        _targetWriteRange = new(charStart, charEnd);
        _isWriting = true;
    }

    private void SetTargetScrollLine(int line)
    {
        if (ScrollSpeed == 0)
        {
            _targetScrollValue = GetLineOffset(line);
            _scrollBar.Value = _targetScrollValue;
            _isScrolling = false;
            return;
        }

        _movingScrollValue = _scrollBar.Value;
        _targetScrollValue = GetLineOffset(line);

        if (_targetScrollValue != _movingScrollValue)
            _isScrolling = true;
    }

    private int GetFirstFittingLine(double startingOffset)
    {
        int totalLines = GetLineCount();

        for (int i = 0; i < totalLines; i++)
        {
            float lineTop = GetLineOffset(i);

            if (lineTop >= startingOffset)
                return i;
        }

        return 0;
    }

    private int GetLastFittingCharacter(double startingOffset)
    {
        int line = GetLastFittingLine(startingOffset);
        Vector2I range = GetLineRange(line);
        return range.Y;
    }

    /// <summary>
    /// Finds the last line that can fit on the screen.
    /// </summary>
    /// <param name="startingOffset">
    /// The vertical scroll offset from which to begin searching.
    /// </param>
    /// <returns></returns>
    private int GetLastFittingLine(double startingOffset)
    {
        int totalLines = GetLineCount();
        float controlHeight = Size.Y;
        float contentHeight = GetContentHeight();
        int lastLine = 0;
        float lineTop;
        float lineBottom = 0;

        for (int i = 0; i < totalLines; i++)
        {
            lineTop = lineBottom;
            lineBottom = (i + 1 < totalLines) ? GetLineOffset(i + 1) : contentHeight;

            if (lineTop <= startingOffset || lineBottom <= startingOffset + controlHeight)
                lastLine = i;

            if (lineTop > startingOffset + controlHeight)
                break;
        }

        return lastLine;
    }

    /// <summary>
    /// Finds the first line index that, when scrolled to the top of the RichTextLabel,
    /// still leaves the following line fully visible in the viewport.
    /// </summary>
    /// <param name="lastFittingLine">
    /// The last visible line to start from.
    /// </param>
    /// <returns>
    /// The index of the line that can be aligned to the top
    /// while keeping its next line fully in view.
    /// </returns>
    private int GetNextFittingLine(int lastFittingLine)
    {
        int totalLines = GetLineCount();
        float controlHeight = Size.Y;

        if (lastFittingLine >= totalLines - 1)
            return totalLines - 1;

        int line = lastFittingLine + 1;
        int totalSize = GetLineHeight(line);

        if (totalSize >= controlHeight)
            return line;

        while (line > 0)
        {
            int prevLineHeight = GetLineHeight(line - 1);

            if (totalSize + prevLineHeight > controlHeight)
                break;

            totalSize += prevLineHeight;
            line--;

            if (totalSize == controlHeight)
                break;
        }

        return line;
    }

    private void ScrollProcess(double delta)
    {
        if (ScrollSpeed == 0)
        {
            _scrollBar.Value = _targetScrollValue;
            _isScrolling = false;
            return;
        }

        double speed = ScrollSpeed * delta;
        _movingScrollValue = Mathf.MoveToward(_movingScrollValue, _targetScrollValue, speed);

        if (_movingScrollValue == _targetScrollValue)
        {
            _scrollBar.Value = _targetScrollValue;
            _isScrolling = false;
        }
        else
        {
            if (ScrollStep > 0)
                _scrollBar.Value = Math.Floor(_movingScrollValue / ScrollStep) * ScrollStep;
            else
                _scrollBar.Value = _movingScrollValue;
        }
    }

    private bool TryTriggerTextEvent(int textIndex)
    {
        if (Dialog == null || _textEventIndex >= _textEvents.Count)
            return false;

        TextEvent textEvent = _textEvents[_textEventIndex];

        if (textIndex < textEvent.TextIndex)
            return false;

        _textEventIndex++;
        TextEventTriggered?.Invoke(textEvent);
        return true;
    }

    private void Write(double delta)
    {
        int currentChar = VisibleCharacters;
        bool isComplete = currentChar == -1 || currentChar == TotalChars;

        if (isComplete && TryTriggerTextEvent(currentChar))
            return;

        if (isComplete || currentChar >= _targetWriteRange.Y)
        {
            _isWriting = false;
            FinishedWriting?.Invoke();

            if (AutoProceedEnabled && !isComplete)
                WriteNextPage();

            return;
        }

        double totalSpeed = CharsPerSecond * SpeedMultiplier;

        if (totalSpeed <= 0) // Instant write
        {
            _writeCounter = _targetWriteRange.Y - currentChar;
        }
        else
        {
            if (IsSpeedUpEnabled)
                totalSpeed *= SpeedUpMultiplier;

            _writeCounter += delta * totalSpeed;

            // catch up to target range start
            if (currentChar < _targetWriteRange.X)
                _writeCounter = _targetWriteRange.X - currentChar;
        }

        while (_writeCounter >= 1 && currentChar < _targetWriteRange.Y)
        {
            if (TryTriggerTextEvent(currentChar))
                break;

            _writeCounter--;
            currentChar++;
            VisibleCharacters = currentChar;
            CharWritten?.Invoke(currentChar - 1, CachedText[currentChar - 1]);
        }

        if (_isScrolling)
            ScrollProcess(delta);

        if (currentChar < _targetWriteRange.Y)
            return;

        _writeCounter = 0;

        if (AutoProceedEnabled)
            PauseTimer += AutoProceedTimeout;
    }
}
